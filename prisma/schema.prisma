// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  // Optional: Configure connection pooling
  // directUrl = env("DIRECT_DATABASE_URL") // For Prisma Migrate
}

model User {
  id              String    @id @default(uuid())
  spotifyId       String    @unique @map("spotify_id")
  email           String?
  name            String?   @map("display_name")
  image           String?   @map("image_url")

  // Auth Tokens (Critical for Background Polling)
  refreshToken    String?   @map("refresh_token")
  accessToken     String?   @map("access_token")
  tokenExpiresAt  Int?      @map("token_expires_at")

  // Polling State (The "Cursor" for the Time Machine)
  lastPolledAt    DateTime? @map("last_polled_at")
  isActive        Boolean   @default(true) @map("is_active")
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")

  // Edge Case Handling: Failure Tracking (EC-QUEUE-001 Circuit Breaker)
  lastSuccessfulScrobble  DateTime? @map("last_successful_scrobble")
  consecutiveFailures     Int       @default(0) @map("consecutive_failures")
  lastFailureType         String?   @map("last_failure_type") // "AUTH" | "NETWORK" | "UNKNOWN"
  lastFailedAt            DateTime? @map("last_failed_at")

  // Edge Case Handling: Auth Notifications (EC-AUTH-002)
  authNotificationCount   Int       @default(0) @map("auth_notification_count")
  lastNotificationSent    DateTime? @map("last_notification_sent")

  // Business Logic: Founding Member Cap (EC-BIZ-001, EC-BIZ-003)
  subscriptionPlan        String    @default("free") @map("subscription_plan") // "free" | "pro"
  foundingMemberNumber    Int?      @unique @map("founding_member_number")

  // Relations
  playEvents  PlayEvent[]
  reports     ShareableReport[]

  @@map("users")
}

model ShareableReport {
  id          String   @id @default(uuid())
  userId      String   @map("user_id")
  shareId     String   @unique @map("share_id") // Public shareable ID
  title       String
  description String?
  reportData  String   @map("report_data") // JSON string of report data
  dateRange   String   @map("date_range") // "7d", "30d", etc.
  isPublic    Boolean  @default(true) @map("is_public")
  viewCount   Int      @default(0) @map("view_count")
  createdAt   DateTime @default(now()) @map("created_at")
  expiresAt   DateTime? @map("expires_at")

  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([shareId])
  @@map("shareable_reports")
}

model Artist {
  id        String   @id @default(uuid())
  spotifyId String   @unique @map("spotify_id")
  name      String
  genres    String   @default("") @map("genres") // Stored as comma-separated string for SQLite

  // Relations
  tracks    Track[]  @relation("TrackArtists")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("artists")
}

model Album {
  id        String   @id @default(uuid())
  spotifyId String   @unique @map("spotify_id")
  name      String
  imageUrl  String?  @map("image_url")

  // Relations
  tracks    Track[]

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("albums")
}

model Track {
  id         String   @id @default(uuid())
  spotifyId  String   @unique @map("spotify_id")
  name       String
  durationMs Int      @map("duration_ms")

  // Relations
  album      Album?   @relation(fields: [albumId], references: [id])
  albumId    String?  @map("album_id")
  artists    Artist[] @relation("TrackArtists")
  playEvents PlayEvent[]

  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  @@map("tracks")
}

model PlayEvent {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  trackId   String   @map("track_id")
  playedAt  DateTime @map("played_at")

  // Relations
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  track     Track    @relation(fields: [trackId], references: [id])

  createdAt DateTime @default(now()) @map("created_at")

  // DEDUPLICATION: Prevents duplicate play events
  @@unique([userId, trackId, playedAt])
  @@index([userId, playedAt(sort: Desc)])
  @@map("play_events")
}